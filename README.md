# Домашнее задание к занятию "`Индексы`" - `Репин Андрей`

### Задание 1

Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.


![img](https://github.com/RepinAndrey/index/blob/main/img/1.png)

### Задание 2

Выполните explain analyze следующего запроса:
```sql
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```

    перечислите узкие места;
    оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.


![img](https://github.com/RepinAndrey/index/blob/main/img/2.png)
>  Выборка заняла чуть более 6 секунд

Как видно, основное время занимает вызов оконной функции и сортировка данных
![img](https://github.com/RepinAndrey/index/blob/main/img/3.png)

Анализ запроса показывает, что нет смысла включать в запрос таблицы film и inventory.
Можно отказаться от оконной функции, а использовать группировку по идентификатору пользователя
GROUP BY по customer_id. В этом случае можно убрать и distinct оператор.

Работа запроса в этом случаем быстрее на  три порядка 
![img](https://github.com/RepinAndrey/index/blob/main/img/6.png)


![img](https://github.com/RepinAndrey/index/blob/main/img/4.png)

###Дополнение

Добавлен индекс на payment_date.
Переписал условие where для payment_date следующим образом: payment_date >= ‘2005-07-30’ and payment_date < DATE_ADD(‘2005-07-30’, INTERVAL 1 DAY)

![img](https://github.com/RepinAndrey/index/blob/main/img/7.png)

### Задание 3

Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

Приведите ответ в свободной форме.


Индексы, которые используются в PostgreSQL, а в MySQL — нет:

GiST-индексы (Generalized Search Tree) - это целая индексная инфраструктура, позволяет реализовать много разных стратегий индексирования. Основывается на построении древовидных структур, и используется для геометрических данных и полнотекстового поиска.

SP-GiST-индекс (space partitioned GiST) - GiST с пространственным разделением, SP-GiST позволяет организовывать на диске самые разные несбалансированные структуры данных, такие как деревья квадрантов, k-мерные и префиксные деревья. Полезны для несбалансированных данных, которые имеют естественный элемент кластеризации: ГИС, мультимедиа, IP-маршрутизация.

BRIN-индекс (block range indexes) - хранит обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. Более эффективный по величине и стоимости индекс, по сравнению с B-tree, используется для "биг дата".

GIN-индекс (generalized inverted indexes) - особенно полезный индекс, когда множество значений хранится в одной колонке (json, array, hstore). Это «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений компонентов.



